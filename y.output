Terminals unused in grammar

   LPARENTHESIS
   RPARENTHESIS
   COMMA
   COLON
   SEMICOLON
   LBRACKET
   RBRACKET
   LBRACE
   RBRACE
   CASE
   CLOSE
   CONTINUE
   CYCLE
   GOTO
   PROCEDURE
   RECURSIVE
   SELECT
   STOP
   TYPE
   PERCENT
   CONCAT
   PASSIGNMENT
   IFX
   EQV
   NEQV
   OR
   AND
   NOT
   EXP


Grammar

    0 $accept: program $end

    1 $@1: %empty

    2 $@2: %empty

    3 $@3: %empty

    4 program: PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM ID $@3 subprogram

    5 $@4: %empty

    6 $@5: %empty

    7 $@6: %empty

    8 $@7: %empty

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

   10 $@8: %empty

   11 $@9: %empty

   12 $@10: %empty

   13 $@11: %empty

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram
   15           | %empty

   16 decls: declVar decls
   17      | optionGlob decls
   18      | optionInit decls
   19      | optionDecl decls
   20      | %empty

   21 declVar: types ids
   22        | types CCOLON ids
   23        | types ',' fAttr sAttr CCOLON ids

   24 $@12: %empty

   25 optionGlob: COMMON $@12 '/' ids '/'

   26 optionInit: DATA '/' ID '/' value

   27 optionDecl: PARAMETER '(' ID '=' value ')'

   28 value: INTEGERC
   29      | REALC
   30      | CHARC
   31      | LOGICALC

   32 declF: INTERFACE declFunc END INTERFACE
   33      | %empty

   34 $@13: %empty

   35 $@14: %empty

   36 $@15: %empty

   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc

   38 $@16: %empty

   39 $@17: %empty

   40 $@18: %empty

   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc
   42         | %empty

   43 stmts: assignStmt stmts
   44      | printStmt stmts
   45      | loopStmt stmts
   46      | ifStmt stmts
   47      | RETURN stmts
   48      | EXIT stmts

   49 $@19: %empty

   50 $@20: %empty

   51 stmts: CALL ID $@19 '(' idn ')' $@20 stmts

   52 $@21: %empty

   53 stmts: READ ID $@21 stmts
   54      | %empty

   55 $@22: %empty

   56 printStmt: PRINT $@22 expr

   57 $@23: %empty

   58 printStmt: PRINTLN $@23 expr

   59 assignStmt: ID '=' expr

   60 $@24: %empty

   61 assignStmt: ID '[' expr ']' $@24 '=' expr

   62 $@25: %empty

   63 $@26: %empty

   64 $@27: %empty

   65 loopStmt: DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO

   66 $@28: %empty

   67 ifStmt: IF '(' expr ')' $@28 condition1 END IF

   68 condition1: THEN stmts condition2
   69           | stmts

   70 $@29: %empty

   71 condition2: ELSE $@29 stmts
   72           | %empty

   73 types: INTEGER
   74      | REAL
   75      | LOGICAL
   76      | CHARACTER

   77 idn: ids
   78    | %empty

   79 ids: ids ',' ID
   80    | ID

   81 fAttr: DIMENSION '(' INTEGERC ')'
   82      | DIMENSION '(' error ')'
   83      | POINTER
   84      | PARAMETER

   85 sAttr: ',' POINTER
   86      | %empty

   87 expr: expr '+' expr
   88     | expr '-' expr
   89     | expr '*' expr
   90     | expr '/' expr
   91     | '-' expr
   92     | expr GT expr
   93     | expr GE expr
   94     | expr LT expr
   95     | expr LE expr
   96     | expr EQ expr
   97     | expr NE expr

   98 $@30: %empty

   99 expr: ID $@30 funcCondition
  100     | INTEGERC
  101     | REALC
  102     | CHARC
  103     | LOGICALC
  104     | STRINGC

  105 funcCondition: '(' funcPara ')'
  106              | %empty

  107 funcPara: funcPara ',' opt_val
  108         | opt_val
  109         | %empty

  110 opt_val: INTEGERC
  111        | REALC
  112        | ID

  113 optionExpr: ',' INTEGERC
  114           | ',' ID
  115           | %empty


Terminals, with rules where they appear

$end (0) 0
'(' (40) 9 14 27 37 41 51 67 81 82 105
')' (41) 9 14 27 37 41 51 67 81 82 105
'*' (42) 89
'+' (43) 87
',' (44) 23 65 79 85 107 113 114
'-' (45) 88 91
'/' (47) 25 26 90
'=' (61) 27 59 61
'[' (91) 61
']' (93) 61
error (256) 82
INTEGERC (258) 28 81 100 110 113
REALC (259) 29 101 111
CHARC (260) 30 102
LOGICALC (261) 31 103
ID (262) 4 9 14 26 27 37 41 51 53 59 61 79 80 99 112 114
STRINGC (263) 104
LPARENTHESIS (264)
RPARENTHESIS (265)
COMMA (266)
COLON (267)
CCOLON (268) 22 23
SEMICOLON (269)
LBRACKET (270)
RBRACKET (271)
LBRACE (272)
RBRACE (273)
INTEGER (274) 73
REAL (275) 74
LOGICAL (276) 75
CHARACTER (277) 76
CALL (278) 51
CASE (279)
CLOSE (280)
CONTINUE (281)
CYCLE (282)
DATA (283) 26
DIMENSION (284) 81 82
DO (285) 65
END (286) 4 9 14 32 37 41 65 67
EXIT (287) 48
FUNCTION (288) 14 41
GOTO (289)
PROCEDURE (290)
PARAMETER (291) 27 84
PRINT (292) 56
PRINTLN (293) 58
POINTER (294) 83 85
PROGRAM (295) 4
RECURSIVE (296)
RETURN (297) 47
SELECT (298)
STOP (299)
SUBROUTINE (300) 9 37
TYPE (301)
PERCENT (302)
CONCAT (303)
PASSIGNMENT (304)
INTERFACE (305) 32
THEN (306) 68
IF (307) 67
READ (308) 53
COMMON (309) 25
IFX (310)
ELSE (311) 71
EQV (312)
NEQV (313)
OR (314)
AND (315)
NOT (316)
LT (317) 94
LE (318) 95
GE (319) 93
GT (320) 92
EQ (321) 96
NE (322) 97
EXP (323)
UMINUS (324)


Nonterminals, with rules where they appear

$accept (80)
    on left: 0
program (81)
    on left: 4, on right: 0
$@1 (82)
    on left: 1, on right: 4
$@2 (83)
    on left: 2, on right: 4
$@3 (84)
    on left: 3, on right: 4
subprogram (85)
    on left: 9 14 15, on right: 4 9 14
$@4 (86)
    on left: 5, on right: 9
$@5 (87)
    on left: 6, on right: 9
$@6 (88)
    on left: 7, on right: 9
$@7 (89)
    on left: 8, on right: 9
$@8 (90)
    on left: 10, on right: 14
$@9 (91)
    on left: 11, on right: 14
$@10 (92)
    on left: 12, on right: 14
$@11 (93)
    on left: 13, on right: 14
decls (94)
    on left: 16 17 18 19 20, on right: 4 9 14 16 17 18 19 37 41
declVar (95)
    on left: 21 22 23, on right: 16
optionGlob (96)
    on left: 25, on right: 17
$@12 (97)
    on left: 24, on right: 25
optionInit (98)
    on left: 26, on right: 18
optionDecl (99)
    on left: 27, on right: 19
value (100)
    on left: 28 29 30 31, on right: 26 27
declF (101)
    on left: 32 33, on right: 4
declFunc (102)
    on left: 37 41 42, on right: 32 37 41
$@13 (103)
    on left: 34, on right: 37
$@14 (104)
    on left: 35, on right: 37
$@15 (105)
    on left: 36, on right: 37
$@16 (106)
    on left: 38, on right: 41
$@17 (107)
    on left: 39, on right: 41
$@18 (108)
    on left: 40, on right: 41
stmts (109)
    on left: 43 44 45 46 47 48 51 53 54, on right: 4 9 14 43 44 45
    46 47 48 51 53 65 68 69 71
$@19 (110)
    on left: 49, on right: 51
$@20 (111)
    on left: 50, on right: 51
$@21 (112)
    on left: 52, on right: 53
printStmt (113)
    on left: 56 58, on right: 44
$@22 (114)
    on left: 55, on right: 56
$@23 (115)
    on left: 57, on right: 58
assignStmt (116)
    on left: 59 61, on right: 43 65
$@24 (117)
    on left: 60, on right: 61
loopStmt (118)
    on left: 65, on right: 45
$@25 (119)
    on left: 62, on right: 65
$@26 (120)
    on left: 63, on right: 65
$@27 (121)
    on left: 64, on right: 65
ifStmt (122)
    on left: 67, on right: 46
$@28 (123)
    on left: 66, on right: 67
condition1 (124)
    on left: 68 69, on right: 67
condition2 (125)
    on left: 71 72, on right: 68
$@29 (126)
    on left: 70, on right: 71
types (127)
    on left: 73 74 75 76, on right: 21 22 23
idn (128)
    on left: 77 78, on right: 9 14 37 41 51
ids (129)
    on left: 79 80, on right: 21 22 23 25 77 79
fAttr (130)
    on left: 81 82 83 84, on right: 23
sAttr (131)
    on left: 85 86, on right: 23
expr (132)
    on left: 87 88 89 90 91 92 93 94 95 96 97 99 100 101 102 103 104,
    on right: 56 58 59 61 65 67 87 88 89 90 91 92 93 94 95 96 97
$@30 (133)
    on left: 98, on right: 99
funcCondition (134)
    on left: 105 106, on right: 99
funcPara (135)
    on left: 107 108 109, on right: 105 107
opt_val (136)
    on left: 110 111 112, on right: 107 108
optionExpr (137)
    on left: 113 114 115, on right: 65


State 0

    0 $accept: . program $end
    4 program: . PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM ID $@3 subprogram

    PROGRAM  shift, and go to state 1

    program  go to state 2


State 1

    4 program: PROGRAM . ID $@1 decls declF $@2 stmts END PROGRAM ID $@3 subprogram

    ID  shift, and go to state 3


State 2

    0 $accept: program . $end

    $end  shift, and go to state 4


State 3

    1 $@1: . %empty
    4 program: PROGRAM ID . $@1 decls declF $@2 stmts END PROGRAM ID $@3 subprogram

    $default  reduce using rule 1 ($@1)

    $@1  go to state 5


State 4

    0 $accept: program $end .

    $default  accept


State 5

    4 program: PROGRAM ID $@1 . decls declF $@2 stmts END PROGRAM ID $@3 subprogram
   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 13
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 6

   73 types: INTEGER .

    $default  reduce using rule 73 (types)


State 7

   74 types: REAL .

    $default  reduce using rule 74 (types)


State 8

   75 types: LOGICAL .

    $default  reduce using rule 75 (types)


State 9

   76 types: CHARACTER .

    $default  reduce using rule 76 (types)


State 10

   26 optionInit: DATA . '/' ID '/' value

    '/'  shift, and go to state 19


State 11

   27 optionDecl: PARAMETER . '(' ID '=' value ')'

    '('  shift, and go to state 20


State 12

   24 $@12: . %empty
   25 optionGlob: COMMON . $@12 '/' ids '/'

    $default  reduce using rule 24 ($@12)

    $@12  go to state 21


State 13

    4 program: PROGRAM ID $@1 decls . declF $@2 stmts END PROGRAM ID $@3 subprogram
   32 declF: . INTERFACE declFunc END INTERFACE
   33      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ]

    INTERFACE  shift, and go to state 22

    $default  reduce using rule 33 (declF)

    declF  go to state 23


State 14

   16 decls: . declVar decls
   16      | declVar . decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 24
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 15

   16 decls: . declVar decls
   17      | . optionGlob decls
   17      | optionGlob . decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 25
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 16

   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   18      | optionInit . decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 26
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 17

   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   19      | optionDecl . decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 27
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 18

   21 declVar: types . ids
   22        | types . CCOLON ids
   23        | types . ',' fAttr sAttr CCOLON ids
   79 ids: . ids ',' ID
   80    | . ID

    ID      shift, and go to state 28
    CCOLON  shift, and go to state 29
    ','     shift, and go to state 30

    ids  go to state 31


State 19

   26 optionInit: DATA '/' . ID '/' value

    ID  shift, and go to state 32


State 20

   27 optionDecl: PARAMETER '(' . ID '=' value ')'

    ID  shift, and go to state 33


State 21

   25 optionGlob: COMMON $@12 . '/' ids '/'

    '/'  shift, and go to state 34


State 22

   32 declF: INTERFACE . declFunc END INTERFACE
   37 declFunc: . SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc
   41         | . FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc
   42         | . %empty  [END]

    FUNCTION    shift, and go to state 35
    SUBROUTINE  shift, and go to state 36

    $default  reduce using rule 42 (declFunc)

    declFunc  go to state 37


State 23

    2 $@2: . %empty
    4 program: PROGRAM ID $@1 decls declF . $@2 stmts END PROGRAM ID $@3 subprogram

    $default  reduce using rule 2 ($@2)

    $@2  go to state 38


State 24

   16 decls: declVar decls .

    $default  reduce using rule 16 (decls)


State 25

   17 decls: optionGlob decls .

    $default  reduce using rule 17 (decls)


State 26

   18 decls: optionInit decls .

    $default  reduce using rule 18 (decls)


State 27

   19 decls: optionDecl decls .

    $default  reduce using rule 19 (decls)


State 28

   80 ids: ID .

    $default  reduce using rule 80 (ids)


State 29

   22 declVar: types CCOLON . ids
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    ids  go to state 39


State 30

   23 declVar: types ',' . fAttr sAttr CCOLON ids
   81 fAttr: . DIMENSION '(' INTEGERC ')'
   82      | . DIMENSION '(' error ')'
   83      | . POINTER
   84      | . PARAMETER

    DIMENSION  shift, and go to state 40
    PARAMETER  shift, and go to state 41
    POINTER    shift, and go to state 42

    fAttr  go to state 43


State 31

   21 declVar: types ids .  [ID, INTEGER, REAL, LOGICAL, CHARACTER, CALL, DATA, DO, END, EXIT, PARAMETER, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ, COMMON]
   79 ids: ids . ',' ID

    ','  shift, and go to state 44

    $default  reduce using rule 21 (declVar)


State 32

   26 optionInit: DATA '/' ID . '/' value

    '/'  shift, and go to state 45


State 33

   27 optionDecl: PARAMETER '(' ID . '=' value ')'

    '='  shift, and go to state 46


State 34

   25 optionGlob: COMMON $@12 '/' . ids '/'
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    ids  go to state 47


State 35

   41 declFunc: FUNCTION . ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc

    ID  shift, and go to state 48


State 36

   37 declFunc: SUBROUTINE . ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc

    ID  shift, and go to state 49


State 37

   32 declF: INTERFACE declFunc . END INTERFACE

    END  shift, and go to state 50


State 38

    4 program: PROGRAM ID $@1 decls declF $@2 . stmts END PROGRAM ID $@3 subprogram
   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 60
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 39

   22 declVar: types CCOLON ids .  [ID, INTEGER, REAL, LOGICAL, CHARACTER, CALL, DATA, DO, END, EXIT, PARAMETER, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ, COMMON]
   79 ids: ids . ',' ID

    ','  shift, and go to state 44

    $default  reduce using rule 22 (declVar)


State 40

   81 fAttr: DIMENSION . '(' INTEGERC ')'
   82      | DIMENSION . '(' error ')'

    '('  shift, and go to state 65


State 41

   84 fAttr: PARAMETER .

    $default  reduce using rule 84 (fAttr)


State 42

   83 fAttr: POINTER .

    $default  reduce using rule 83 (fAttr)


State 43

   23 declVar: types ',' fAttr . sAttr CCOLON ids
   85 sAttr: . ',' POINTER
   86      | . %empty  [CCOLON]

    ','  shift, and go to state 66

    $default  reduce using rule 86 (sAttr)

    sAttr  go to state 67


State 44

   79 ids: ids ',' . ID

    ID  shift, and go to state 68


State 45

   26 optionInit: DATA '/' ID '/' . value
   28 value: . INTEGERC
   29      | . REALC
   30      | . CHARC
   31      | . LOGICALC

    INTEGERC  shift, and go to state 69
    REALC     shift, and go to state 70
    CHARC     shift, and go to state 71
    LOGICALC  shift, and go to state 72

    value  go to state 73


State 46

   27 optionDecl: PARAMETER '(' ID '=' . value ')'
   28 value: . INTEGERC
   29      | . REALC
   30      | . CHARC
   31      | . LOGICALC

    INTEGERC  shift, and go to state 69
    REALC     shift, and go to state 70
    CHARC     shift, and go to state 71
    LOGICALC  shift, and go to state 72

    value  go to state 74


State 47

   25 optionGlob: COMMON $@12 '/' ids . '/'
   79 ids: ids . ',' ID

    '/'  shift, and go to state 75
    ','  shift, and go to state 44


State 48

   38 $@16: . %empty
   41 declFunc: FUNCTION ID . $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc

    $default  reduce using rule 38 ($@16)

    $@16  go to state 76


State 49

   34 $@13: . %empty
   37 declFunc: SUBROUTINE ID . $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc

    $default  reduce using rule 34 ($@13)

    $@13  go to state 77


State 50

   32 declF: INTERFACE declFunc END . INTERFACE

    INTERFACE  shift, and go to state 78


State 51

   59 assignStmt: ID . '=' expr
   61           | ID . '[' expr ']' $@24 '=' expr

    '='  shift, and go to state 79
    '['  shift, and go to state 80


State 52

   51 stmts: CALL . ID $@19 '(' idn ')' $@20 stmts

    ID  shift, and go to state 81


State 53

   62 $@25: . %empty
   65 loopStmt: DO . $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO

    $default  reduce using rule 62 ($@25)

    $@25  go to state 82


State 54

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   48      | EXIT . stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 83
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 55

   55 $@22: . %empty
   56 printStmt: PRINT . $@22 expr

    $default  reduce using rule 55 ($@22)

    $@22  go to state 84


State 56

   57 $@23: . %empty
   58 printStmt: PRINTLN . $@23 expr

    $default  reduce using rule 57 ($@23)

    $@23  go to state 85


State 57

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   47      | RETURN . stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 86
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 58

   67 ifStmt: IF . '(' expr ')' $@28 condition1 END IF

    '('  shift, and go to state 87


State 59

   53 stmts: READ . ID $@21 stmts

    ID  shift, and go to state 88


State 60

    4 program: PROGRAM ID $@1 decls declF $@2 stmts . END PROGRAM ID $@3 subprogram

    END  shift, and go to state 89


State 61

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   44      | printStmt . stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 90
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 62

   43 stmts: . assignStmt stmts
   43      | assignStmt . stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 91
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 63

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   45      | loopStmt . stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 92
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 64

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   46      | ifStmt . stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 93
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 65

   81 fAttr: DIMENSION '(' . INTEGERC ')'
   82      | DIMENSION '(' . error ')'

    error     shift, and go to state 94
    INTEGERC  shift, and go to state 95


State 66

   85 sAttr: ',' . POINTER

    POINTER  shift, and go to state 96


State 67

   23 declVar: types ',' fAttr sAttr . CCOLON ids

    CCOLON  shift, and go to state 97


State 68

   79 ids: ids ',' ID .

    $default  reduce using rule 79 (ids)


State 69

   28 value: INTEGERC .

    $default  reduce using rule 28 (value)


State 70

   29 value: REALC .

    $default  reduce using rule 29 (value)


State 71

   30 value: CHARC .

    $default  reduce using rule 30 (value)


State 72

   31 value: LOGICALC .

    $default  reduce using rule 31 (value)


State 73

   26 optionInit: DATA '/' ID '/' value .

    $default  reduce using rule 26 (optionInit)


State 74

   27 optionDecl: PARAMETER '(' ID '=' value . ')'

    ')'  shift, and go to state 98


State 75

   25 optionGlob: COMMON $@12 '/' ids '/' .

    $default  reduce using rule 25 (optionGlob)


State 76

   41 declFunc: FUNCTION ID $@16 . '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc

    '('  shift, and go to state 99


State 77

   37 declFunc: SUBROUTINE ID $@13 . '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc

    '('  shift, and go to state 100


State 78

   32 declF: INTERFACE declFunc END INTERFACE .

    $default  reduce using rule 32 (declF)


State 79

   59 assignStmt: ID '=' . expr
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 108


State 80

   61 assignStmt: ID '[' . expr ']' $@24 '=' expr
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 109


State 81

   49 $@19: . %empty
   51 stmts: CALL ID . $@19 '(' idn ')' $@20 stmts

    $default  reduce using rule 49 ($@19)

    $@19  go to state 110


State 82

   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: DO $@25 . assignStmt $@26 ',' expr $@27 optionExpr stmts END DO

    ID  shift, and go to state 51

    assignStmt  go to state 111


State 83

   48 stmts: EXIT stmts .

    $default  reduce using rule 48 (stmts)


State 84

   56 printStmt: PRINT $@22 . expr
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 112


State 85

   58 printStmt: PRINTLN $@23 . expr
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 113


State 86

   47 stmts: RETURN stmts .

    $default  reduce using rule 47 (stmts)


State 87

   67 ifStmt: IF '(' . expr ')' $@28 condition1 END IF
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 114


State 88

   52 $@21: . %empty
   53 stmts: READ ID . $@21 stmts

    $default  reduce using rule 52 ($@21)

    $@21  go to state 115


State 89

    4 program: PROGRAM ID $@1 decls declF $@2 stmts END . PROGRAM ID $@3 subprogram

    PROGRAM  shift, and go to state 116


State 90

   44 stmts: printStmt stmts .

    $default  reduce using rule 44 (stmts)


State 91

   43 stmts: assignStmt stmts .

    $default  reduce using rule 43 (stmts)


State 92

   45 stmts: loopStmt stmts .

    $default  reduce using rule 45 (stmts)


State 93

   46 stmts: ifStmt stmts .

    $default  reduce using rule 46 (stmts)


State 94

   82 fAttr: DIMENSION '(' error . ')'

    ')'  shift, and go to state 117


State 95

   81 fAttr: DIMENSION '(' INTEGERC . ')'

    ')'  shift, and go to state 118


State 96

   85 sAttr: ',' POINTER .

    $default  reduce using rule 85 (sAttr)


State 97

   23 declVar: types ',' fAttr sAttr CCOLON . ids
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    ids  go to state 119


State 98

   27 optionDecl: PARAMETER '(' ID '=' value ')' .

    $default  reduce using rule 27 (optionDecl)


State 99

   41 declFunc: FUNCTION ID $@16 '(' . idn ')' $@17 decls END FUNCTION ID $@18 declFunc
   77 idn: . ids
   78    | . %empty  [')']
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    $default  reduce using rule 78 (idn)

    idn  go to state 120
    ids  go to state 121


State 100

   37 declFunc: SUBROUTINE ID $@13 '(' . idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc
   77 idn: . ids
   78    | . %empty  [')']
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    $default  reduce using rule 78 (idn)

    idn  go to state 122
    ids  go to state 121


State 101

  100 expr: INTEGERC .

    $default  reduce using rule 100 (expr)


State 102

  101 expr: REALC .

    $default  reduce using rule 101 (expr)


State 103

  102 expr: CHARC .

    $default  reduce using rule 102 (expr)


State 104

  103 expr: LOGICALC .

    $default  reduce using rule 103 (expr)


State 105

   98 $@30: . %empty
   99 expr: ID . $@30 funcCondition

    $default  reduce using rule 98 ($@30)

    $@30  go to state 123


State 106

  104 expr: STRINGC .

    $default  reduce using rule 104 (expr)


State 107

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   91     | '-' . expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 124


State 108

   59 assignStmt: ID '=' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, ',']
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 59 (assignStmt)


State 109

   61 assignStmt: ID '[' expr . ']' $@24 '=' expr
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134
    ']'  shift, and go to state 135


State 110

   51 stmts: CALL ID $@19 . '(' idn ')' $@20 stmts

    '('  shift, and go to state 136


State 111

   63 $@26: . %empty
   65 loopStmt: DO $@25 assignStmt . $@26 ',' expr $@27 optionExpr stmts END DO

    $default  reduce using rule 63 ($@26)

    $@26  go to state 137


State 112

   56 printStmt: PRINT $@22 expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE]
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 56 (printStmt)


State 113

   58 printStmt: PRINTLN $@23 expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE]
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 58 (printStmt)


State 114

   67 ifStmt: IF '(' expr . ')' $@28 condition1 END IF
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134
    ')'  shift, and go to state 138


State 115

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   53      | READ ID $@21 . stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 139
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 116

    4 program: PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM . ID $@3 subprogram

    ID  shift, and go to state 140


State 117

   82 fAttr: DIMENSION '(' error ')' .

    $default  reduce using rule 82 (fAttr)


State 118

   81 fAttr: DIMENSION '(' INTEGERC ')' .

    $default  reduce using rule 81 (fAttr)


State 119

   23 declVar: types ',' fAttr sAttr CCOLON ids .  [ID, INTEGER, REAL, LOGICAL, CHARACTER, CALL, DATA, DO, END, EXIT, PARAMETER, PRINT, PRINTLN, RETURN, INTERFACE, IF, READ, COMMON]
   79 ids: ids . ',' ID

    ','  shift, and go to state 44

    $default  reduce using rule 23 (declVar)


State 120

   41 declFunc: FUNCTION ID $@16 '(' idn . ')' $@17 decls END FUNCTION ID $@18 declFunc

    ')'  shift, and go to state 141


State 121

   77 idn: ids .  [')']
   79 ids: ids . ',' ID

    ','  shift, and go to state 44

    $default  reduce using rule 77 (idn)


State 122

   37 declFunc: SUBROUTINE ID $@13 '(' idn . ')' $@14 decls END SUBROUTINE ID $@15 declFunc

    ')'  shift, and go to state 142


State 123

   99 expr: ID $@30 . funcCondition
  105 funcCondition: . '(' funcPara ')'
  106              | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', '*', '/', ')', ',', ']']

    '('  shift, and go to state 143

    $default  reduce using rule 106 (funcCondition)

    funcCondition  go to state 144


State 124

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   91     | '-' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', '*', '/', ')', ',', ']']
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    $default  reduce using rule 91 (expr)

    Conflict between rule 91 and token LT resolved as reduce (LT < UMINUS).
    Conflict between rule 91 and token LE resolved as reduce (LE < UMINUS).
    Conflict between rule 91 and token GE resolved as reduce (GE < UMINUS).
    Conflict between rule 91 and token GT resolved as reduce (GT < UMINUS).
    Conflict between rule 91 and token EQ resolved as reduce (EQ < UMINUS).
    Conflict between rule 91 and token NE resolved as reduce (NE < UMINUS).
    Conflict between rule 91 and token '+' resolved as reduce ('+' < UMINUS).
    Conflict between rule 91 and token '-' resolved as reduce ('-' < UMINUS).
    Conflict between rule 91 and token '*' resolved as reduce ('*' < UMINUS).
    Conflict between rule 91 and token '/' resolved as reduce ('/' < UMINUS).


State 125

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   94     | expr LT . expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 145


State 126

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   95     | expr LE . expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 146


State 127

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   93     | expr GE . expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 147


State 128

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   92     | expr GT . expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 148


State 129

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   96     | expr EQ . expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 149


State 130

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   97     | expr NE . expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 150


State 131

   87 expr: . expr '+' expr
   87     | expr '+' . expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 151


State 132

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   88     | expr '-' . expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 152


State 133

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   89     | expr '*' . expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 153


State 134

   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   90     | expr '/' . expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 154


State 135

   60 $@24: . %empty
   61 assignStmt: ID '[' expr ']' . $@24 '=' expr

    $default  reduce using rule 60 ($@24)

    $@24  go to state 155


State 136

   51 stmts: CALL ID $@19 '(' . idn ')' $@20 stmts
   77 idn: . ids
   78    | . %empty  [')']
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    $default  reduce using rule 78 (idn)

    idn  go to state 156
    ids  go to state 121


State 137

   65 loopStmt: DO $@25 assignStmt $@26 . ',' expr $@27 optionExpr stmts END DO

    ','  shift, and go to state 157


State 138

   66 $@28: . %empty
   67 ifStmt: IF '(' expr ')' . $@28 condition1 END IF

    $default  reduce using rule 66 ($@28)

    $@28  go to state 158


State 139

   53 stmts: READ ID $@21 stmts .

    $default  reduce using rule 53 (stmts)


State 140

    3 $@3: . %empty
    4 program: PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM ID . $@3 subprogram

    $default  reduce using rule 3 ($@3)

    $@3  go to state 159


State 141

   39 $@17: . %empty
   41 declFunc: FUNCTION ID $@16 '(' idn ')' . $@17 decls END FUNCTION ID $@18 declFunc

    $default  reduce using rule 39 ($@17)

    $@17  go to state 160


State 142

   35 $@14: . %empty
   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' . $@14 decls END SUBROUTINE ID $@15 declFunc

    $default  reduce using rule 35 ($@14)

    $@14  go to state 161


State 143

  105 funcCondition: '(' . funcPara ')'
  107 funcPara: . funcPara ',' opt_val
  108         | . opt_val
  109         | . %empty  [')', ',']
  110 opt_val: . INTEGERC
  111        | . REALC
  112        | . ID

    INTEGERC  shift, and go to state 162
    REALC     shift, and go to state 163
    ID        shift, and go to state 164

    $default  reduce using rule 109 (funcPara)

    funcPara  go to state 165
    opt_val   go to state 166


State 144

   99 expr: ID $@30 funcCondition .

    $default  reduce using rule 99 (expr)


State 145

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   94     | expr LT expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 94 (expr)

    Conflict between rule 94 and token LT resolved as reduce (%left LT).
    Conflict between rule 94 and token LE resolved as reduce (%left LE).
    Conflict between rule 94 and token GE resolved as reduce (%left GE).
    Conflict between rule 94 and token GT resolved as reduce (%left GT).
    Conflict between rule 94 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 94 and token NE resolved as reduce (%left NE).
    Conflict between rule 94 and token '+' resolved as shift (LT < '+').
    Conflict between rule 94 and token '-' resolved as shift (LT < '-').
    Conflict between rule 94 and token '*' resolved as shift (LT < '*').
    Conflict between rule 94 and token '/' resolved as shift (LT < '/').


State 146

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   95     | expr LE expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']
   96     | expr . EQ expr
   97     | expr . NE expr

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 95 (expr)

    Conflict between rule 95 and token LT resolved as reduce (%left LT).
    Conflict between rule 95 and token LE resolved as reduce (%left LE).
    Conflict between rule 95 and token GE resolved as reduce (%left GE).
    Conflict between rule 95 and token GT resolved as reduce (%left GT).
    Conflict between rule 95 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 95 and token NE resolved as reduce (%left NE).
    Conflict between rule 95 and token '+' resolved as shift (LE < '+').
    Conflict between rule 95 and token '-' resolved as shift (LE < '-').
    Conflict between rule 95 and token '*' resolved as shift (LE < '*').
    Conflict between rule 95 and token '/' resolved as shift (LE < '/').


State 147

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   93     | expr GE expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 93 (expr)

    Conflict between rule 93 and token LT resolved as reduce (%left LT).
    Conflict between rule 93 and token LE resolved as reduce (%left LE).
    Conflict between rule 93 and token GE resolved as reduce (%left GE).
    Conflict between rule 93 and token GT resolved as reduce (%left GT).
    Conflict between rule 93 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 93 and token NE resolved as reduce (%left NE).
    Conflict between rule 93 and token '+' resolved as shift (GE < '+').
    Conflict between rule 93 and token '-' resolved as shift (GE < '-').
    Conflict between rule 93 and token '*' resolved as shift (GE < '*').
    Conflict between rule 93 and token '/' resolved as shift (GE < '/').


State 148

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   92     | expr GT expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 92 (expr)

    Conflict between rule 92 and token LT resolved as reduce (%left LT).
    Conflict between rule 92 and token LE resolved as reduce (%left LE).
    Conflict between rule 92 and token GE resolved as reduce (%left GE).
    Conflict between rule 92 and token GT resolved as reduce (%left GT).
    Conflict between rule 92 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 92 and token NE resolved as reduce (%left NE).
    Conflict between rule 92 and token '+' resolved as shift (GT < '+').
    Conflict between rule 92 and token '-' resolved as shift (GT < '-').
    Conflict between rule 92 and token '*' resolved as shift (GT < '*').
    Conflict between rule 92 and token '/' resolved as shift (GT < '/').


State 149

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   96     | expr EQ expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']
   97     | expr . NE expr

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 96 (expr)

    Conflict between rule 96 and token LT resolved as reduce (%left LT).
    Conflict between rule 96 and token LE resolved as reduce (%left LE).
    Conflict between rule 96 and token GE resolved as reduce (%left GE).
    Conflict between rule 96 and token GT resolved as reduce (%left GT).
    Conflict between rule 96 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 96 and token NE resolved as reduce (%left NE).
    Conflict between rule 96 and token '+' resolved as shift (EQ < '+').
    Conflict between rule 96 and token '-' resolved as shift (EQ < '-').
    Conflict between rule 96 and token '*' resolved as shift (EQ < '*').
    Conflict between rule 96 and token '/' resolved as shift (EQ < '/').


State 150

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr
   97     | expr NE expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, ')', ',', ']']

    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 97 (expr)

    Conflict between rule 97 and token LT resolved as reduce (%left LT).
    Conflict between rule 97 and token LE resolved as reduce (%left LE).
    Conflict between rule 97 and token GE resolved as reduce (%left GE).
    Conflict between rule 97 and token GT resolved as reduce (%left GT).
    Conflict between rule 97 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 97 and token NE resolved as reduce (%left NE).
    Conflict between rule 97 and token '+' resolved as shift (NE < '+').
    Conflict between rule 97 and token '-' resolved as shift (NE < '-').
    Conflict between rule 97 and token '*' resolved as shift (NE < '*').
    Conflict between rule 97 and token '/' resolved as shift (NE < '/').


State 151

   87 expr: expr . '+' expr
   87     | expr '+' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', ')', ',', ']']
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 87 (expr)

    Conflict between rule 87 and token LT resolved as reduce (LT < '+').
    Conflict between rule 87 and token LE resolved as reduce (LE < '+').
    Conflict between rule 87 and token GE resolved as reduce (GE < '+').
    Conflict between rule 87 and token GT resolved as reduce (GT < '+').
    Conflict between rule 87 and token EQ resolved as reduce (EQ < '+').
    Conflict between rule 87 and token NE resolved as reduce (NE < '+').
    Conflict between rule 87 and token '+' resolved as reduce (%left '+').
    Conflict between rule 87 and token '-' resolved as reduce (%left '-').
    Conflict between rule 87 and token '*' resolved as shift ('+' < '*').
    Conflict between rule 87 and token '/' resolved as shift ('+' < '/').


State 152

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   88     | expr '-' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', ')', ',', ']']
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 88 (expr)

    Conflict between rule 88 and token LT resolved as reduce (LT < '-').
    Conflict between rule 88 and token LE resolved as reduce (LE < '-').
    Conflict between rule 88 and token GE resolved as reduce (GE < '-').
    Conflict between rule 88 and token GT resolved as reduce (GT < '-').
    Conflict between rule 88 and token EQ resolved as reduce (EQ < '-').
    Conflict between rule 88 and token NE resolved as reduce (NE < '-').
    Conflict between rule 88 and token '+' resolved as reduce (%left '+').
    Conflict between rule 88 and token '-' resolved as reduce (%left '-').
    Conflict between rule 88 and token '*' resolved as shift ('-' < '*').
    Conflict between rule 88 and token '/' resolved as shift ('-' < '/').


State 153

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   89     | expr '*' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', '*', '/', ')', ',', ']']
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    $default  reduce using rule 89 (expr)

    Conflict between rule 89 and token LT resolved as reduce (LT < '*').
    Conflict between rule 89 and token LE resolved as reduce (LE < '*').
    Conflict between rule 89 and token GE resolved as reduce (GE < '*').
    Conflict between rule 89 and token GT resolved as reduce (GT < '*').
    Conflict between rule 89 and token EQ resolved as reduce (EQ < '*').
    Conflict between rule 89 and token NE resolved as reduce (NE < '*').
    Conflict between rule 89 and token '+' resolved as reduce ('+' < '*').
    Conflict between rule 89 and token '-' resolved as reduce ('-' < '*').
    Conflict between rule 89 and token '*' resolved as reduce (%left '*').
    Conflict between rule 89 and token '/' resolved as reduce (%left '/').


State 154

   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   90     | expr '/' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, LT, LE, GE, GT, EQ, NE, '+', '-', '*', '/', ')', ',', ']']
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    $default  reduce using rule 90 (expr)

    Conflict between rule 90 and token LT resolved as reduce (LT < '/').
    Conflict between rule 90 and token LE resolved as reduce (LE < '/').
    Conflict between rule 90 and token GE resolved as reduce (GE < '/').
    Conflict between rule 90 and token GT resolved as reduce (GT < '/').
    Conflict between rule 90 and token EQ resolved as reduce (EQ < '/').
    Conflict between rule 90 and token NE resolved as reduce (NE < '/').
    Conflict between rule 90 and token '+' resolved as reduce ('+' < '/').
    Conflict between rule 90 and token '-' resolved as reduce ('-' < '/').
    Conflict between rule 90 and token '*' resolved as reduce (%left '*').
    Conflict between rule 90 and token '/' resolved as reduce (%left '/').


State 155

   61 assignStmt: ID '[' expr ']' $@24 . '=' expr

    '='  shift, and go to state 167


State 156

   51 stmts: CALL ID $@19 '(' idn . ')' $@20 stmts

    ')'  shift, and go to state 168


State 157

   65 loopStmt: DO $@25 assignStmt $@26 ',' . expr $@27 optionExpr stmts END DO
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 169


State 158

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF
   67       | IF '(' expr ')' $@28 . condition1 END IF
   68 condition1: . THEN stmts condition2
   69           | . stmts

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    THEN     shift, and go to state 170
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 171
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64
    condition1  go to state 172


State 159

    4 program: PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM ID $@3 . subprogram
    9 subprogram: . SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram
   14           | . FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram
   15           | . %empty  [$end]

    FUNCTION    shift, and go to state 173
    SUBROUTINE  shift, and go to state 174

    $default  reduce using rule 15 (subprogram)

    subprogram  go to state 175


State 160

   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [END]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 . decls END FUNCTION ID $@18 declFunc
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 176
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 161

   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [END]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 . decls END SUBROUTINE ID $@15 declFunc
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 177
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 162

  110 opt_val: INTEGERC .

    $default  reduce using rule 110 (opt_val)


State 163

  111 opt_val: REALC .

    $default  reduce using rule 111 (opt_val)


State 164

  112 opt_val: ID .

    $default  reduce using rule 112 (opt_val)


State 165

  105 funcCondition: '(' funcPara . ')'
  107 funcPara: funcPara . ',' opt_val

    ')'  shift, and go to state 178
    ','  shift, and go to state 179


State 166

  108 funcPara: opt_val .

    $default  reduce using rule 108 (funcPara)


State 167

   61 assignStmt: ID '[' expr ']' $@24 '=' . expr
   87 expr: . expr '+' expr
   88     | . expr '-' expr
   89     | . expr '*' expr
   90     | . expr '/' expr
   91     | . '-' expr
   92     | . expr GT expr
   93     | . expr GE expr
   94     | . expr LT expr
   95     | . expr LE expr
   96     | . expr EQ expr
   97     | . expr NE expr
   99     | . ID $@30 funcCondition
  100     | . INTEGERC
  101     | . REALC
  102     | . CHARC
  103     | . LOGICALC
  104     | . STRINGC

    INTEGERC  shift, and go to state 101
    REALC     shift, and go to state 102
    CHARC     shift, and go to state 103
    LOGICALC  shift, and go to state 104
    ID        shift, and go to state 105
    STRINGC   shift, and go to state 106
    '-'       shift, and go to state 107

    expr  go to state 180


State 168

   50 $@20: . %empty
   51 stmts: CALL ID $@19 '(' idn ')' . $@20 stmts

    $default  reduce using rule 50 ($@20)

    $@20  go to state 181


State 169

   64 $@27: . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ',']
   65 loopStmt: DO $@25 assignStmt $@26 ',' expr . $@27 optionExpr stmts END DO
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 64 ($@27)

    $@27  go to state 182


State 170

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF
   68 condition1: THEN . stmts condition2

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 183
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 171

   69 condition1: stmts .

    $default  reduce using rule 69 (condition1)


State 172

   67 ifStmt: IF '(' expr ')' $@28 condition1 . END IF

    END  shift, and go to state 184


State 173

   14 subprogram: FUNCTION . ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram

    ID  shift, and go to state 185


State 174

    9 subprogram: SUBROUTINE . ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

    ID  shift, and go to state 186


State 175

    4 program: PROGRAM ID $@1 decls declF $@2 stmts END PROGRAM ID $@3 subprogram .

    $default  reduce using rule 4 (program)


State 176

   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls . END FUNCTION ID $@18 declFunc

    END  shift, and go to state 187


State 177

   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls . END SUBROUTINE ID $@15 declFunc

    END  shift, and go to state 188


State 178

  105 funcCondition: '(' funcPara ')' .

    $default  reduce using rule 105 (funcCondition)


State 179

  107 funcPara: funcPara ',' . opt_val
  110 opt_val: . INTEGERC
  111        | . REALC
  112        | . ID

    INTEGERC  shift, and go to state 162
    REALC     shift, and go to state 163
    ID        shift, and go to state 164

    opt_val  go to state 189


State 180

   61 assignStmt: ID '[' expr ']' $@24 '=' expr .  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ, ELSE, ',']
   87 expr: expr . '+' expr
   88     | expr . '-' expr
   89     | expr . '*' expr
   90     | expr . '/' expr
   92     | expr . GT expr
   93     | expr . GE expr
   94     | expr . LT expr
   95     | expr . LE expr
   96     | expr . EQ expr
   97     | expr . NE expr

    LT   shift, and go to state 125
    LE   shift, and go to state 126
    GE   shift, and go to state 127
    GT   shift, and go to state 128
    EQ   shift, and go to state 129
    NE   shift, and go to state 130
    '+'  shift, and go to state 131
    '-'  shift, and go to state 132
    '*'  shift, and go to state 133
    '/'  shift, and go to state 134

    $default  reduce using rule 61 (assignStmt)


State 181

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   51      | CALL ID $@19 '(' idn ')' $@20 . stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END, ELSE]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 190
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 182

   65 loopStmt: DO $@25 assignStmt $@26 ',' expr $@27 . optionExpr stmts END DO
  113 optionExpr: . ',' INTEGERC
  114           | . ',' ID
  115           | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ]

    ','  shift, and go to state 191

    $default  reduce using rule 115 (optionExpr)

    optionExpr  go to state 192


State 183

   68 condition1: THEN stmts . condition2
   71 condition2: . ELSE $@29 stmts
   72           | . %empty  [END]

    ELSE  shift, and go to state 193

    $default  reduce using rule 72 (condition2)

    condition2  go to state 194


State 184

   67 ifStmt: IF '(' expr ')' $@28 condition1 END . IF

    IF  shift, and go to state 195


State 185

   10 $@8: . %empty
   14 subprogram: FUNCTION ID . $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram

    $default  reduce using rule 10 ($@8)

    $@8  go to state 196


State 186

    5 $@4: . %empty
    9 subprogram: SUBROUTINE ID . $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

    $default  reduce using rule 5 ($@4)

    $@4  go to state 197


State 187

   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls END . FUNCTION ID $@18 declFunc

    FUNCTION  shift, and go to state 198


State 188

   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls END . SUBROUTINE ID $@15 declFunc

    SUBROUTINE  shift, and go to state 199


State 189

  107 funcPara: funcPara ',' opt_val .

    $default  reduce using rule 107 (funcPara)


State 190

   51 stmts: CALL ID $@19 '(' idn ')' $@20 stmts .

    $default  reduce using rule 51 (stmts)


State 191

  113 optionExpr: ',' . INTEGERC
  114           | ',' . ID

    INTEGERC  shift, and go to state 200
    ID        shift, and go to state 201


State 192

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   65         | DO $@25 assignStmt $@26 ',' expr $@27 optionExpr . stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 202
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 193

   70 $@29: . %empty
   71 condition2: ELSE . $@29 stmts

    $default  reduce using rule 70 ($@29)

    $@29  go to state 203


State 194

   68 condition1: THEN stmts condition2 .

    $default  reduce using rule 68 (condition1)


State 195

   67 ifStmt: IF '(' expr ')' $@28 condition1 END IF .

    $default  reduce using rule 67 (ifStmt)


State 196

   14 subprogram: FUNCTION ID $@8 . '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram

    '('  shift, and go to state 204


State 197

    9 subprogram: SUBROUTINE ID $@4 . '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

    '('  shift, and go to state 205


State 198

   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION . ID $@18 declFunc

    ID  shift, and go to state 206


State 199

   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE . ID $@15 declFunc

    ID  shift, and go to state 207


State 200

  113 optionExpr: ',' INTEGERC .

    $default  reduce using rule 113 (optionExpr)


State 201

  114 optionExpr: ',' ID .

    $default  reduce using rule 114 (optionExpr)


State 202

   65 loopStmt: DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts . END DO

    END  shift, and go to state 208


State 203

   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF
   71 condition2: ELSE $@29 . stmts

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 209
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 204

   14 subprogram: FUNCTION ID $@8 '(' . idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram
   77 idn: . ids
   78    | . %empty  [')']
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    $default  reduce using rule 78 (idn)

    idn  go to state 210
    ids  go to state 121


State 205

    9 subprogram: SUBROUTINE ID $@4 '(' . idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram
   77 idn: . ids
   78    | . %empty  [')']
   79 ids: . ids ',' ID
   80    | . ID

    ID  shift, and go to state 28

    $default  reduce using rule 78 (idn)

    idn  go to state 211
    ids  go to state 121


State 206

   40 $@18: . %empty
   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID . $@18 declFunc

    $default  reduce using rule 40 ($@18)

    $@18  go to state 212


State 207

   36 $@15: . %empty
   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID . $@15 declFunc

    $default  reduce using rule 36 ($@15)

    $@15  go to state 213


State 208

   65 loopStmt: DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END . DO

    DO  shift, and go to state 214


State 209

   71 condition2: ELSE $@29 stmts .

    $default  reduce using rule 71 (condition2)


State 210

   14 subprogram: FUNCTION ID $@8 '(' idn . ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram

    ')'  shift, and go to state 215


State 211

    9 subprogram: SUBROUTINE ID $@4 '(' idn . ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

    ')'  shift, and go to state 216


State 212

   37 declFunc: . SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc
   41         | . FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc
   41         | FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 . declFunc
   42         | . %empty  [END]

    FUNCTION    shift, and go to state 35
    SUBROUTINE  shift, and go to state 36

    $default  reduce using rule 42 (declFunc)

    declFunc  go to state 217


State 213

   37 declFunc: . SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc
   37         | SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 . declFunc
   41         | . FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc
   42         | . %empty  [END]

    FUNCTION    shift, and go to state 35
    SUBROUTINE  shift, and go to state 36

    $default  reduce using rule 42 (declFunc)

    declFunc  go to state 218


State 214

   65 loopStmt: DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO .

    $default  reduce using rule 65 (loopStmt)


State 215

   11 $@9: . %empty
   14 subprogram: FUNCTION ID $@8 '(' idn ')' . $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram

    $default  reduce using rule 11 ($@9)

    $@9  go to state 219


State 216

    6 $@5: . %empty
    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' . $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram

    $default  reduce using rule 6 ($@5)

    $@5  go to state 220


State 217

   41 declFunc: FUNCTION ID $@16 '(' idn ')' $@17 decls END FUNCTION ID $@18 declFunc .

    $default  reduce using rule 41 (declFunc)


State 218

   37 declFunc: SUBROUTINE ID $@13 '(' idn ')' $@14 decls END SUBROUTINE ID $@15 declFunc .

    $default  reduce using rule 37 (declFunc)


State 219

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 . decls $@10 stmts END FUNCTION ID $@11 subprogram
   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 221
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 220

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 . decls $@6 stmts END SUBROUTINE ID $@7 subprogram
   16 decls: . declVar decls
   17      | . optionGlob decls
   18      | . optionInit decls
   19      | . optionDecl decls
   20      | . %empty  [ID, CALL, DO, END, EXIT, PRINT, PRINTLN, RETURN, IF, READ]
   21 declVar: . types ids
   22        | . types CCOLON ids
   23        | . types ',' fAttr sAttr CCOLON ids
   25 optionGlob: . COMMON $@12 '/' ids '/'
   26 optionInit: . DATA '/' ID '/' value
   27 optionDecl: . PARAMETER '(' ID '=' value ')'
   73 types: . INTEGER
   74      | . REAL
   75      | . LOGICAL
   76      | . CHARACTER

    INTEGER    shift, and go to state 6
    REAL       shift, and go to state 7
    LOGICAL    shift, and go to state 8
    CHARACTER  shift, and go to state 9
    DATA       shift, and go to state 10
    PARAMETER  shift, and go to state 11
    COMMON     shift, and go to state 12

    $default  reduce using rule 20 (decls)

    decls       go to state 222
    declVar     go to state 14
    optionGlob  go to state 15
    optionInit  go to state 16
    optionDecl  go to state 17
    types       go to state 18


State 221

   12 $@10: . %empty
   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls . $@10 stmts END FUNCTION ID $@11 subprogram

    $default  reduce using rule 12 ($@10)

    $@10  go to state 223


State 222

    7 $@6: . %empty
    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls . $@6 stmts END SUBROUTINE ID $@7 subprogram

    $default  reduce using rule 7 ($@6)

    $@6  go to state 224


State 223

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 . stmts END FUNCTION ID $@11 subprogram
   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 225
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 224

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 . stmts END SUBROUTINE ID $@7 subprogram
   43 stmts: . assignStmt stmts
   44      | . printStmt stmts
   45      | . loopStmt stmts
   46      | . ifStmt stmts
   47      | . RETURN stmts
   48      | . EXIT stmts
   51      | . CALL ID $@19 '(' idn ')' $@20 stmts
   53      | . READ ID $@21 stmts
   54      | . %empty  [END]
   56 printStmt: . PRINT $@22 expr
   58          | . PRINTLN $@23 expr
   59 assignStmt: . ID '=' expr
   61           | . ID '[' expr ']' $@24 '=' expr
   65 loopStmt: . DO $@25 assignStmt $@26 ',' expr $@27 optionExpr stmts END DO
   67 ifStmt: . IF '(' expr ')' $@28 condition1 END IF

    ID       shift, and go to state 51
    CALL     shift, and go to state 52
    DO       shift, and go to state 53
    EXIT     shift, and go to state 54
    PRINT    shift, and go to state 55
    PRINTLN  shift, and go to state 56
    RETURN   shift, and go to state 57
    IF       shift, and go to state 58
    READ     shift, and go to state 59

    $default  reduce using rule 54 (stmts)

    stmts       go to state 226
    printStmt   go to state 61
    assignStmt  go to state 62
    loopStmt    go to state 63
    ifStmt      go to state 64


State 225

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts . END FUNCTION ID $@11 subprogram

    END  shift, and go to state 227


State 226

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts . END SUBROUTINE ID $@7 subprogram

    END  shift, and go to state 228


State 227

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END . FUNCTION ID $@11 subprogram

    FUNCTION  shift, and go to state 229


State 228

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END . SUBROUTINE ID $@7 subprogram

    SUBROUTINE  shift, and go to state 230


State 229

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION . ID $@11 subprogram

    ID  shift, and go to state 231


State 230

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE . ID $@7 subprogram

    ID  shift, and go to state 232


State 231

   13 $@11: . %empty
   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID . $@11 subprogram

    $default  reduce using rule 13 ($@11)

    $@11  go to state 233


State 232

    8 $@7: . %empty
    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID . $@7 subprogram

    $default  reduce using rule 8 ($@7)

    $@7  go to state 234


State 233

    9 subprogram: . SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram
   14           | . FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram
   14           | FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 . subprogram
   15           | . %empty  [$end]

    FUNCTION    shift, and go to state 173
    SUBROUTINE  shift, and go to state 174

    $default  reduce using rule 15 (subprogram)

    subprogram  go to state 235


State 234

    9 subprogram: . SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram
    9           | SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 . subprogram
   14           | . FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram
   15           | . %empty  [$end]

    FUNCTION    shift, and go to state 173
    SUBROUTINE  shift, and go to state 174

    $default  reduce using rule 15 (subprogram)

    subprogram  go to state 236


State 235

   14 subprogram: FUNCTION ID $@8 '(' idn ')' $@9 decls $@10 stmts END FUNCTION ID $@11 subprogram .

    $default  reduce using rule 14 (subprogram)


State 236

    9 subprogram: SUBROUTINE ID $@4 '(' idn ')' $@5 decls $@6 stmts END SUBROUTINE ID $@7 subprogram .

    $default  reduce using rule 9 (subprogram)
